# Span\<T\>
_________________________________________________________________________________________

### В C# 7.2 ([C# 7.2](https://github.com/sharpist/C_Sharp/tree/master/7.2#c-72)) был добавлен тип ```Span<T>```, который позволяет создать коллекцию данных, ###
### хранимую в стеке, но доступ к которой осуществляется по ссылке. ###
_________________________________________________________________________________________

```Span<T>``` является небольшим, но критически важным строительным блоком в огромных
предпринимаемых усилиях по оснащению .NET API для разработки высокопроизводительных
серверных приложений с высокой масштабируемостью.
Тип ```Memory<T>``` является расширением типа ```Span<T>``` и используется для потокобезопасного
доступа по ссылке к коллекции хранимой в стеке.

```System.Span<T>``` – это новый тип значений в основе .NET. Который, делает возможным
представление сопредельных областей произвольной памяти, независимо от того, связана ли
эта память с управляемым объектом, обеспечивается ли она нативным (машинным) кодом,
вызываемым из управляемого кода с помощью Interop или находится в стеке.
При этом сохраняется безопасный доступ с такими эксплуатационными характеристиками, как
характеристики массивов.

В отличие от массивов, он может указывать на управляемую или нативную память, или на
память, выделенную в стеке:
```c#
// managed memory
var arrayMemory = new byte[100];
var arraySpan = new Span<byte>(arrayMemory);

// native memory
var nativeMemory = Marshal.AllocHGlobal(100);
Span<byte> nativeSpan;
unsafe
{
    nativeSpan = new Span<byte>(nativeMemory.ToPointer(), 100);
}
SafeSum(nativeSpan);
Marshal.FreeHGlobal(nativeMemory);

// stack memory
Span<byte> stackSpan = stackalloc byte[100];
SafeSum(stackSpan);
```

#### Таким образом, ```Span<T>``` является абстракцией по всем типам памяти, доступным для .NET-программ: ####
```c#
// не имеет значения с каким видом памяти работает метод
static ulong SafeSum(Span<byte> bytes)
{
    ulong sum = 0;
    for (int i = 0; i < bytes.Length; i++)
        sum += bytes[i];

    return sum;
}
```
_________________________________________________________________________________________

```Span<T>``` реализован только для стека; точнее, это by-ref тип (как и его поле в
быстрой реализации). Это означает, что ```Span``` не может быть упакован, не может
отображаться как поле типа, отличного от стека, и не может использоваться в качестве
обобщённого аргумента.
Однако ```Span<T>``` может использоваться как тип аргументов метода или возвращаемых
значений.

```Span<T>``` поддерживает переинтерпретацию приведения к ```Span<byte>```. Он также
поддерживает небезопасные приведения между произвольными примитивными типами. Причина
этого ограничения заключается в том, что некоторые процессоры не поддерживают эффективный невыровненный
доступ к памяти.

В отличие от ```T[]```, ```Span<T>``` не поддерживает ковариантные приведения, т.е.
приведение ```Span<Subtype>``` к ```Span<Basetype>```, не выполняются проверки ковариации
при хранении ссылок в экземплярах ```Span<T>```.

#### Особенности: ####

1. Принудительное ограничение типа только для стека.

* ```Span<T>``` и ```ReadOnlySpan<T>``` включены в набор встроенных типов только для
стека.

* любая другая структура, содержащая один из них, будет транзитивно считаться типом
только для стека.

* компилятор выдаст ошибку, если тип только стека используется в запрещенном контексте,
например, используется в качестве аргумента типа, помещённого в кучу (упаковка,
передается в асинхронный вызов, используется в качестве поля класса и т.д.).

2. Языковая поддержка для закрепления.
```c#
Span<byte> buffer = ...
fixed(byte* pBuffer = buffer)
{
    ...
}
```

3. Синтаксис среза.

* ```Memory<T>```, ```Span<T>``` и ```ReadOnlySpan<T>``` допускают синтаксис среза.

4. Безопасный ```Span<T>``` stackalloc ([stackalloc](https://github.com/sharpist/C_Sharp/tree/master/Stackalloc#stackalloc)).
```c#
void SafeMethod()
{
    Span<byte> buffer = stackalloc byte[128];
    PrimitiveFormatter.TryFormat(buffer, DateTime.Now, ...);
}
```

5. Примитивное ограничение.

* возможность ограничивать параметры типа примитивными типами (которые являются битными),
некоторые операции ```Span<T>``` допустимы только для так называемых аргументов
примитивного типа, например, операция переинтерпретации приведения.
```c#
// операция приведения ограничивает параметры типа
public static Span<U> Cast<T, U>(this Span<T> slice) where T:primitive where U:primitive
{ ... }
```
_________________________________________________________________________________________

При обёртывании массива ```Span<T>``` не ограничивается указанием на первый элемент массива.
Он может указывать на любой поддиапазон. Другими словами, он поддерживает резку:
```c#
var array = new byte[] { 1, 2, 3 };
var slice = new Span<byte>(array, start:1, length:2);
Console.WriteLine(slice[0]); // 2
```
*версия ```Span<T>``` только для чтения – ```ReadOnlySpan<T>``` требуется для представления
срезов неизменяемых и доступных только для чтения структур, например System.String cрезы

Например, создав ```Span<T>``` из массива:
```c#
var arr = new byte[10];
Span<byte> bytes = arr; // неявное приведение из T[] в Span<T>
```
Можно эффективно создать ```Span``` чтобы представить/указать только подмножество этого
массива, используя перегруженный метод ```Span<T>.Slice```.
Затем индексировать полученный результирующий ```Span``` для записи или чтения данных в
соответствующей уместной части исходного массива:
```c#
Span<byte> slicedBytes = bytes.Slice(start: 5, length: 2);
slicedBytes[0] = 42;
slicedBytes[1] = 43;
Assert.Equal(42, slicedBytes[0]);
Assert.Equal(43, slicedBytes[1]);
Assert.Equal(arr[5], slicedBytes[0]);
Assert.Equal(arr[6], slicedBytes[1]);
slicedBytes[2] = 44; // Throws IndexOutOfRangeException
bytes[2] = 45; // OK
Assert.Equal(arr[2], bytes[2]);
Assert.Equal(45, arr[2]);
```

Как уже упоминалось, ```Span``` – это больше, чем просто способ доступа к массивам и их
подмножествам. Они также могут использоваться для ссылки на данные в стеке:
```c#
Span<byte> bytes = stackalloc byte[2]; // C# 7.2 поддержка stackalloc для spans
bytes[0] = 42;
bytes[1] = 43;
Assert.Equal(42, bytes[0]);
Assert.Equal(43, bytes[1]);
bytes[2] = 44; // throws IndexOutOfRangeException
```
В более общем плане они могут использоваться для ссылки на произвольные указатели и
длины, например на память, выделенную из нативной кучи:
```c#
IntPtr ptr = Marshal.AllocHGlobal(1);
try
{
  Span<byte> bytes;
  unsafe { bytes = new Span<byte>((byte*)ptr, 1); }
  bytes[0] = 42;
  Assert.Equal(42, bytes[0]);
  Assert.Equal(Marshal.ReadByte(ptr), bytes[0]);
  bytes[1] = 43; // Throws IndexOutOfRangeException
}
finally { Marshal.FreeHGlobal(ptr); }
```

Индексатор ```Span<T>``` использует преимущество языка C#, представленную в C# 7.0
функциональность, которая называется ```ref returns```.
Индексатор объявляется с возвращаемым типом ```ref T```, который предоставляет семантику,
подобную индексации в массивах, возвращая ссылку на фактическое актуальное расположение
хранилища, вместо возврата копии того, что существует в этом расположении:
```c#
public ref T this[int index] { get { ... } }
```
Влияние этого возвращающего по ссылке индексатора наиболее очевидно путем сравнения его
с индексатором ```List<T>```, который не является возвращающим по ссылке:
```c#
struct MutableStruct { public int Value; }
...
Span<MutableStruct> spanOfStructs = new MutableStruct[1];
spanOfStructs[0].Value = 42;
Assert.Equal(42, spanOfStructs[0].Value);
var listOfStructs = new List<MutableStruct> { new MutableStruct() };
listOfStructs[0].Value = 42; // Error CS1612: the return value is not a variable
```
Второй вариант ```Span<T>```, называемый ```System.ReadOnlySpan<T>```, обеспечивает доступ только
для чтения.
Этот тип похож на ```Span<T>```, за исключением того, что его индексатор поддерживает
преимущество C# 7.2 новую функциональность для возврата ```ref readonly T``` вместо ```ref T```, что
позволяет ему работать с неизменяемыми типами данных, такими как System.String.
```ReadOnlySpan<T>``` делает это очень эффективным для среза строк без выделения или
копирования:
```c#
string str = "hello, world";
string worldString = str.Substring(startIndex: 7, length: 5); // Allocates
ReadOnlySpan<char> worldSpan =
  str.AsSpan().Slice(start: 7, length: 5); // No allocation
Assert.Equal('w', worldSpan[0]);
worldSpan[0] = 'a'; // Error CS0200: indexer cannot be assigned to
```

```Span``` предоставляет множество преимуществ, помимо тех, которые уже упоминались.
Он поддерживает понятие переинтерпретации приведения, то есть возможно использовать
приведение ```Span<byte>``` к ```Span<int>``` (где 0-й индекс в ```Span<int>``` отображает первые четыре
байта ```Span<byte>```).
Таким образом, при чтении буфера байтов, предоставляется возможность передавать методу,
который оперирует с сгруппированными байтами как с значениями типа ```int``` безопасно и
эффективно.
_________________________________________________________________________________________

#### Организация ```Span<T>```: ####


Во-первых, ```Span<T>``` – это тип значения, содержащий ссылку и длину, определяемый примерно
следующим образом:
```c#
public readonly ref struct Span<T>
{
  private readonly ref T _pointer;
  private readonly int _length;
  ...
}
```
Концепция поля ```ref T``` может выглядеть странно поначалу, фактически невозможно объявить
поле ```ref T``` в C# или даже в MSIL.
Но ```Span<T>``` на самом деле написан для использования особого внутреннего типа в Runtime,
который рассматривается как just-in-time (JIT) встроенный код, с JIT-генерацией для него
эквивалента поля ```ref T```.
Привычное использование ссылок:
```c#
public static void AddOne(ref int value) => value += 1;
...
var values = new int[] { 42, 84, 126 };
AddOne(ref values[2]);
Assert.Equal(127, values[2]);
```
Здесь код передаёт элемент в массиве по ссылке, так что имеется ```ref T``` в стеке, ```ref T``` в
```Span<T>``` – это та же идея, просто инкапсулированная внутри структуры.
Типы, которые содержат такие ссылки напрямую или косвенно, называются ref-подобными
типами, и компилятор C# 7.2 позволяет объявлять такие ref-подобные типы с помощью
```ref struct``` в сигнатуре.


Отсюда следует:

1. ```Span<T>``` определяется таким образом, что операции могут быть столь же эффективными,
как и в массивах:
индексирование в ```Span``` не требует вычислений для нахождения начала из указателя и его
начального смещения, поскольку само поле ref в себе уже инкапсулирует оба
(напротив, ```ArraySegment<T>``` имеет отдельное поле смещения, что делает его более
дорогостоящим как для индексации, так и для прохождения).

2. Природа ```Span<T>``` как ref-подобного типа несет с собой некоторые ограничения из-за его
поля ```ref T```.

Второй пункт имеет некоторые интересные последствия, вследствие чего .NET содержит второй и связанный набор типов, ведомый ```Memory<T>```.

