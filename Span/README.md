# Span\<T\>
_________________________________________________________________________________________

### В C# 7.2 ([C# 7.2](https://github.com/sharpist/C_Sharp/tree/master/7.2#c-72)) был добавлен тип ```Span<T>```, который позволяет создать коллекцию данных, ###
### хранимую в стеке, но доступ к которой осуществляется по ссылке. ###
_________________________________________________________________________________________

```Span<T>``` является небольшим, но критически важным строительным блоком в огромных
предпринимаемых усилиях по оснащению .NET API для разработки высокопроизводительных
серверных приложений с высокой масштабируемостью.
Тип ```Memory<T>``` является расширением типа ```Span<T>``` и используется для потокобезопасного
доступа по ссылке к коллекции хранимой в стеке.

```System.Span<T>``` – это новый тип значений в основе .NET. Который, делает возможным
представление сопредельных областей произвольной памяти, независимо от того, связана ли
эта память с управляемым объектом, обеспечивается ли она нативным (машинным) кодом,
вызываемым из управляемого кода с помощью Interop или находится в стеке.
При этом сохраняется безопасный доступ с такими эксплуатационными характеристиками, как
характеристики массивов.

В отличие от массивов, он может указывать на управляемую или нативную память, или на
память, выделенную в стеке:
```c#
// managed memory
var arrayMemory = new byte[100];
var arraySpan = new Span<byte>(arrayMemory);

// native memory
var nativeMemory = Marshal.AllocHGlobal(100);
Span<byte> nativeSpan;
unsafe
{
    nativeSpan = new Span<byte>(nativeMemory.ToPointer(), 100);
}
SafeSum(nativeSpan);
Marshal.FreeHGlobal(nativeMemory);

// stack memory
Span<byte> stackSpan = stackalloc byte[100];
SafeSum(stackSpan);
```

#### Таким образом, ```Span<T>``` является абстракцией по всем типам памяти, доступным для .NET-программ: ####
```c#
// не имеет значения с каким видом памяти работает метод
static ulong SafeSum(Span<byte> bytes)
{
    ulong sum = 0;
    for (int i = 0; i < bytes.Length; i++)
        sum += bytes[i];

    return sum;
}
```
_________________________________________________________________________________________

```Span<T>``` реализован только для стека; точнее, это by-ref тип (как и его поле в
быстрой реализации). Это означает, что ```Span``` не может быть упакован, не может
отображаться как поле типа, отличного от стека, и не может использоваться в качестве
обобщённого аргумента.
Однако ```Span<T>``` может использоваться как тип аргументов метода или возвращаемых
значений.

```Span<T>``` поддерживает переинтерпретацию приведения к ```Span<byte>```. Он также
поддерживает небезопасные приведения между произвольными примитивными типами. Причина
этого ограничения заключается в том, что некоторые процессоры не поддерживают эффективный невыровненный
доступ к памяти.

В отличие от ```T[]```, ```Span<T>``` не поддерживает ковариантные приведения, т.е.
приведение ```Span<Subtype>``` к ```Span<Basetype>```, не выполняются проверки ковариации
при хранении ссылок в экземплярах ```Span<T>```.

#### Особенности: ####

1. Принудительное ограничение типа только для стека.

* ```Span<T>``` и ```ReadOnlySpan<T>``` включены в набор встроенных типов только для
стека.

* любая другая структура, содержащая один из них, будет транзитивно считаться типом
только для стека.

* компилятор выдаст ошибку, если тип только для стека используется в запрещенном
контексте, например, используется в качестве аргумента типа, помещённого в кучу
(упаковка, отправка в асинхронный вызов, использование в качестве поля класса и т.д.).

2. Языковая поддержка для закрепления.
```c#
Span<byte> buffer = ...
fixed(byte* pBuffer = buffer)
{
    ...
}
```

3. Синтаксис среза.

* ```Memory<T>```, ```Span<T>``` и ```ReadOnlySpan<T>``` допускают синтаксис среза.

4. Безопасный ```Span<T>``` stackalloc ([stackalloc](https://github.com/sharpist/C_Sharp/tree/master/Stackalloc#stackalloc)).
```c#
void SafeMethod()
{
    Span<byte> buffer = stackalloc byte[128];
    PrimitiveFormatter.TryFormat(buffer, DateTime.Now, ...);
}
```

5. Примитивное ограничение.

* возможность ограничивать параметры типа примитивными типами (которые являются битными),
некоторые операции ```Span<T>``` допустимы только для так называемых аргументов
примитивного типа, например, операция переинтерпретации приведения.
```c#
// операция приведения ограничивает параметры типа
public static Span<U> Cast<T, U>(this Span<T> slice) where T:primitive where U:primitive
{ ... }
```
_________________________________________________________________________________________

При обёртывании массива ```Span<T>``` не ограничивается указанием на первый элемент массива.
Он может указывать на любой поддиапазон. Другими словами, он поддерживает резку:
```c#
var array = new byte[] { 1, 2, 3 };
var slice = new Span<byte>(array, start:1, length:2);
Console.WriteLine(slice[0]); // 2
```
*версия ```Span<T>``` только для чтения – ```ReadOnlySpan<T>``` требуется для представления
срезов неизменяемых и доступных только для чтения структур, например System.String cрезы

Например, создав ```Span<T>``` из массива:
```c#
var arr = new byte[10];
Span<byte> bytes = arr; // неявное приведение из T[] в Span<T>
```
Можно эффективно создать ```Span``` чтобы представить/указать только подмножество этого
массива, используя перегруженный метод ```Span<T>.Slice```.
Затем индексировать полученный результирующий ```Span``` для записи или чтения данных в
соответствующей уместной части исходного массива:
```c#
Span<byte> slicedBytes = bytes.Slice(start: 5, length: 2);
slicedBytes[0] = 42;
slicedBytes[1] = 43;
Assert.Equal(42, slicedBytes[0]);
Assert.Equal(43, slicedBytes[1]);
Assert.Equal(arr[5], slicedBytes[0]);
Assert.Equal(arr[6], slicedBytes[1]);
slicedBytes[2] = 44; // Throws IndexOutOfRangeException
bytes[2] = 45; // OK
Assert.Equal(arr[2], bytes[2]);
Assert.Equal(45, arr[2]);
```

Как уже упоминалось, ```Span``` – это больше, чем просто способ доступа к массивам и их
подмножествам. Они также могут использоваться для ссылки на данные в стеке:
```c#
Span<byte> bytes = stackalloc byte[2]; // C# 7.2 поддержка stackalloc для spans
bytes[0] = 42;
bytes[1] = 43;
Assert.Equal(42, bytes[0]);
Assert.Equal(43, bytes[1]);
bytes[2] = 44; // throws IndexOutOfRangeException
```
В более общем плане они могут использоваться для ссылки на произвольные указатели и
длины, например на память, выделенную из нативной кучи:
```c#
IntPtr ptr = Marshal.AllocHGlobal(1);
try
{
  Span<byte> bytes;
  unsafe { bytes = new Span<byte>((byte*)ptr, 1); }
  bytes[0] = 42;
  Assert.Equal(42, bytes[0]);
  Assert.Equal(Marshal.ReadByte(ptr), bytes[0]);
  bytes[1] = 43; // Throws IndexOutOfRangeException
}
finally { Marshal.FreeHGlobal(ptr); }
```

Индексатор ```Span<T>``` использует преимущество языка C#, представленную в C# 7.0
функциональность, которая называется ```ref returns```.
Индексатор объявляется с возвращаемым типом ```ref T```, который предоставляет семантику,
подобную индексации в массивах, возвращая ссылку на фактическое актуальное расположение
хранилища, вместо возврата копии того, что существует в этом расположении:
```c#
public ref T this[int index] { get { ... } }
```
Влияние этого возвращающего по ссылке индексатора наиболее очевидно путем сравнения его
с индексатором ```List<T>```, который не является возвращающим по ссылке:
```c#
struct MutableStruct { public int Value; }
...
Span<MutableStruct> spanOfStructs = new MutableStruct[1];
spanOfStructs[0].Value = 42;
Assert.Equal(42, spanOfStructs[0].Value);
var listOfStructs = new List<MutableStruct> { new MutableStruct() };
listOfStructs[0].Value = 42; // Error CS1612: the return value is not a variable
```
Второй вариант ```Span<T>```, называемый ```System.ReadOnlySpan<T>```, обеспечивает доступ только
для чтения.
Этот тип похож на ```Span<T>```, за исключением того, что его индексатор поддерживает
преимущество C# 7.2 новую функциональность для возврата ```ref readonly T``` вместо ```ref T```, что
позволяет ему работать с неизменяемыми типами данных, такими как System.String.
```ReadOnlySpan<T>``` делает это очень эффективным для среза строк без выделения или
копирования:
```c#
string str = "hello, world";
string worldString = str.Substring(startIndex: 7, length: 5); // Allocates
ReadOnlySpan<char> worldSpan =
  str.AsSpan().Slice(start: 7, length: 5); // No allocation
Assert.Equal('w', worldSpan[0]);
worldSpan[0] = 'a'; // Error CS0200: indexer cannot be assigned to
```

```Span``` предоставляет множество преимуществ, помимо тех, которые уже упоминались.
Он поддерживает понятие переинтерпретации приведения, то есть возможно использовать
приведение ```Span<byte>``` к ```Span<int>``` (где 0-й индекс в ```Span<int>``` отображает первые четыре
байта ```Span<byte>```).
Таким образом, при чтении буфера байтов, предоставляется возможность передавать методу,
который оперирует с сгруппированными байтами как с значениями типа ```int``` безопасно и
эффективно.
_________________________________________________________________________________________

#### Организация ```Span<T>```: ####

```Span<T>``` – это тип значения, содержащий ссылку и длину, определяемый примерно следующим
образом:
```c#
public readonly ref struct Span<T>
{
  private readonly ref T _pointer;
  private readonly int _length;
  ...
}
```
Концепция поля ```ref T``` может выглядеть странно поначалу, фактически невозможно объявить
поле ```ref T``` в C# или даже в MSIL.
Но ```Span<T>``` на самом деле написан для использования особого внутреннего типа в Runtime,
который рассматривается как just-in-time (JIT) встроенный код, с JIT-генерацией для него
эквивалента поля ```ref T```.

Привычное использование ссылок:
```c#
public static void AddOne(ref int value) => value += 1;
...
var values = new int[] { 42, 84, 126 };
AddOne(ref values[2]);
Assert.Equal(127, values[2]);
```
Здесь код передаёт элемент в массиве по ссылке, так что имеется ```ref T``` в стеке, ```ref T``` в
```Span<T>``` – это та же идея, просто инкапсулированная внутри структуры.
Типы, которые содержат такие ссылки напрямую или косвенно, называются ref-подобными
типами, и компилятор C# 7.2 позволяет объявлять такие ref-подобные типы с помощью
```ref struct``` в сигнатуре.


Отсюда следует:

1. ```Span<T>``` определяется таким образом, что операции могут быть столь же эффективными,
как и в массивах:
индексирование в ```Span``` не требует вычислений для нахождения начала из указателя и его
начального смещения, поскольку само поле ref в себе уже инкапсулирует оба

(напротив, ```ArraySegment<T>``` имеет отдельное поле смещения, что делает его более
дорогостоящим как для индексации, так и для прохождения).

2. Природа ```Span<T>``` как ref-подобного типа несет с собой некоторые ограничения из-за его
поля ```ref T```.

Второй пункт имеет некоторые интересные последствия, вследствие чего .NET содержит второй и связанный набор типов, ведомый ```Memory<T>```.
_________________________________________________________________________________________

# Memory\<T\>

```Span<T>``` – это ref-подобный тип, поскольку он содержит поле ref, а поля ref могут
ссылаться не только на начало объектов, например, таких как массивы, но и на их середину:
```c#
var arr = new byte[100];
Span<byte> interiorRef1 = arr.AsSpan(start: 20);
Span<byte> interiorRef2 = new Span<byte>(arr, 20, arr.Length – 20);
Span<byte> interiorRef3 =
  MemoryMarshal.CreateSpan<byte>(arr, ref arr[20], arr.Length – 20);
```
Эти ссылки называются внутренними указателями, и их отслеживание является относительно
дорогостоящей операцией для сборщика мусора среды выполнения .NET.

Таким образом, среда выполнения ограничивает эти ссылки только для работы в стеке,
поскольку она предусмартивает неявный нижний предел на количество внутренних указателей,
которые могут существовать.

Кроме того, ```Span<T>```, как показано выше, больше, чем размер машинного слова, что означает,
что чтение и запись span не является атомарной операцией. Если несколько потоков
считывают и записывают поля span в куче одновременно, существует риск "разрыва".
Например, предварительно уже инициализированный span содержит действующую ссылку и
соответствующую длину ```_length``` равную 50.
Если первый поток начнёт записывать новый span поверх него и дойдёт до записи нового
значения указателя ```_pointer```. Прежде чем он сможет установить соответствующую длину
```_length``` в 20, второй поток может считывать span, включая обновлённый ```_pointer```, но старый
(и более длинный).


#### В результате экземпляры ```Span<T>``` могут находиться только в стеке, а не в куче: ####

1. Это означает, что не допускается упаковка span (и, следовательно, невозможно использовать
```Span<T>``` с существующими API-интерфейсами вызова отражения, например, поскольку они
требуют упаковки).

2. Это также означает, что невозможно иметь поля ```Span<T>``` в классах или даже в не
ref-подобных структурах. Не допускается использовать span в тех местах, где они могут
неявно становиться полями в классах, например, путем захвата их в лямбда-выражения или
в качестве локальных участников в асинхронных методах или итераторах.

3. Это также приводит к тому, что запрещено использовать ```Span<T>``` в качестве обобщённого
универсального аргумента, поскольку экземпляры этого типа аргумента могут оказаться в
упаковке или иным образом сохранены в куче (в настоящее время нет ограничения
```where T : ref struct```).

Эти ограничения несущественны для многих сценариев, в частности для функций
вычислительной и синхронной обработки. Однако асинхронные функции уже другая история.
Большинство упомянутых проблем, связанных с массивами, срезами массивов, нативной
памятью и другие, существуют независимо от того, связаны ли они с синхронными или
асинхронными операциями.


Таким образом, если ```Span<T>``` не может быть сохранен в куче и, следовательно, не может
быть сохранен в асинхронных операциях, каково решение? Решение – ```Memory<T>```.

```Memory<T>``` очень похож на ```ArraySegment<T>```:
```c#
public readonly struct Memory<T>
{
  private readonly object _object;
  private readonly int _index;
  private readonly int _length;
  ...
}
```

```Memory<T>``` можно создать из массива, используя так же, как и span его зрезы, но это будет
не ref-подобная структура и способная существовать в куче.

Затем, когда потребуется выполнить синхронную обработку, можно от него получить ```Span<T>```:
```c#
static async Task<int> ChecksumReadAsync(Memory<byte> buffer, Stream stream)
{
  int bytesRead = await stream.ReadAsync(buffer);
  return Checksum(buffer.Span.Slice(0, bytesRead));
  // Or buffer.Slice(0, bytesRead).Span
}
static int Checksum(Span<byte> buffer) { ... }
```

Как и в случае ```Span<T>``` и ```ReadOnlySpan<T>```, ```Memory<T>``` имеет эквивалент только для чтения – 
```ReadOnlyMemory<T>```. И, как и следовало ожидать, свойство ```Span``` возвращает ```ReadOnlySpan<T>```.


Краткий обзор встроенных механизмов преобразования между этими типами:

![screen capture 1](01.png)

Следует заметить, что поле ```_object``` в ```Memory<T>``` не является строго типизированным как ```T[]```;
точнее, оно хранится как объект. Это означает, что ```Memory<T>``` может обёртывать объекты,
отличные от массивов, например подобные ```System.Buffers.OwnedMemory<T>```.

```OwnedMemory<T>``` – это абстрактный класс, который может использоваться для обёртывания
данных, жизненный цикл которых должен быть постоянно строго управляемым, например, такой,
как память, извлеченная из пула.
Это более сложная тема здесь не рассматривается, но именно таким образом можно
использовать ```Memory<T>```, например, для обёртывания (переноса, конвертации) указателей в
машинную память.

```ReadOnlyMemory<char>``` может также использоваться со строками, так же как может
```ReadOnlySpan<char>```.
_________________________________________________________________________________________

#### Особенности интеграции ```Span<T>``` и ```Memory<T>``` с библиотеками .NET: ####

В предыдущем фрагменте кода ```Memory<T>``` можно заметить вызов ```Stream.ReadAsync```, в который
передаётся ```Memory<byte>```.
Но ```Stream.ReadAsync``` в .NET сегодня определяется для восприятия ```byte[]```. Тогда как это
работает?

В поддержку ```Span<T>``` и преемников, добавляются сотни новых участников и типов сквозь .NET.
Многие из которых являются перегрузками существующих основанных на массивах и строках
методов, в то время как другие являются совершенно новыми типами, ориентированными на
определенные специфичные области обработки.

Например, все примитивные типы, такие как простейший тип ```Int32```, теперь имеют перегрузки
метода синтаксического анализа ```Parse```, которые принимают ```ReadOnlySpan<char>``` в дополнение к
существующим перегрузкам, принимающим строки.

В ситуации, когда ожидается строка, содержащая два числа, разделённые запятой (по типу
"123,456"), и требуется произвести парсинг из этих двух чисел. Сегодня допускается
использовать следующий код:
```c#
string input = ...;
int commaPos = input.IndexOf(',');
int first = int.Parse(input.Substring(0, commaPos));
int second = int.Parse(input.Substring(commaPos + 1));
```
Тем не менее, это, приводит к выделению (allocation) двух строк.
Если создаётся чувствительный к производительности код, вероятно, что два строковых
распределения это уже слишком много. Вместо этого, можно написать:
```c#
string input = ...;
ReadOnlySpan<char> inputSpan = input;
int commaPos = input.IndexOf(',');
int first = int.Parse(inputSpan.Slice(0, commaPos));
int second = int.Parse(inputSpan.Slice(commaPos + 1));
```
Используя новые перегрузки метода синтаксического анализа ```Parse``` на основе Span, целиком
вся эта операция выполнена свободной от выделения ресурсов. ...

_________________________________________________________________________________________
