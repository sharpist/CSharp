#				Patterns
_________________________________________________________________________________________
#### Содержание: ####

[Singleton](https://github.com/sharpist/C_Sharp/tree/master/Patterns#singleton)

...

_________________________________________________________________________________________

#				Singleton
```
Класс, должен иметь только один экземпляр, при этом необходимо обеспечить:
* глобальную точку доступа к экземпляру
* потокобезопасность
```
Представлен сравнительно простой моделью с различными вариантами реализации.


### Стратегии реализации: ###


#### Singleton ####

![screen capture 1](Singleton/01.png)

Эта реализация имеет два основных преимущества:
1. Поскольку экземпляр создается внутри метода свойства экземпляра, класс может выполнять
дополнительные функции (например, создавать экземпляр подкласса), даже если это может
привести к нежелательным зависимостям.

2. Создание экземпляра не выполняется до тех пор, пока объект не запросит экземпляр;
этот подход называется отложенным созданием экземпляра или "ленивым экземпляром".

Отложенное создание экземпляров позволяет избежать создания ненужных синглетов при
запуске приложения.

Основным недостатком этой реализации является то, что она небезопасна для многопоточных
сред. Если отдельные потоки выполнения выполнят метод свойства экземпляра одновременно,
может быть создано несколько экземпляров Singleton.
Каждый поток может выполнить следующую инструкцию решив, что нужно создать новый
экземпляр:
```
if (instance == null)
```


#### Static Initialization ####

В этой стратегии экземпляр создается при первом обращении к любому члену класса.
Инициализация переменной выполняется средой CLR.

![screen capture 2](Singleton/02.png)

Класс помечен как sealed (запечатанный), чтобы предотвратить вывод, который может
добавлять экземпляры. Кроме того, переменная помечена как readonly, что означает, что
её можно назначить только во время статической инициализации (используется в примере)
или в конструкторе класса.

Эта реализация аналогична предыдущему примеру, за исключением того, что для
инициализации переменной используется среда CLR.
По-прежнему реализуются две основные задачи, которые пытается решить шаблон Singleton:
глобальный доступ и управление экземплярами.
```
Свойство public static предоставляет глобальную точку доступа к экземпляру. Кроме того,
поскольку конструктор является закрытым, экземпляр Singleton класса нельзя создать за
пределами самого класса; поэтому переменная ссылается на единственный экземпляр,
который может существовать в системе.
```
Поскольку на экземпляр Singleton ссылается закрытая статическая переменная-член,
создание экземпляра не происходит до тех пор, пока на класс не будет ссылаться вызов
свойства Instance. Таким образом, это решение реализует форму свойства отложенного
создания экземпляра, как в шаблоне проектирования Singleton.

Единственным потенциальным недостатком этого подхода является меньший контроль над
механикой создания экземпляра. В шаблонах проектирования можно было использовать
конструктор по умолчанию или выполнять другие задачи перед созданием экземпляра.
Поскольку .NET Framework выполняет инициализацию в этом решении, эти параметры
отсутствуют.
В большинстве случаев статическая инициализация является предпочтительным подходом
для реализации Singleton в .NET.


#### Multithreaded Singleton ####

Статическая инициализация подходит для большинства ситуаций.

Но если приложению необходимо отложить создание экземпляра, использовать конструктор,
отличный от стандартного, или выполнить другие задачи перед созданием экземпляра, и
работать в многопоточной среде, необходимо другое решение.
```
Существуют случаи, когда нельзя полагаться на среду CLR для обеспечения
потокобезопасности, как в примере статической инициализации. В таких случаях необходимо
использовать определенные языковые возможности, чтобы обеспечить создание только одного
экземпляра объекта при наличии нескольких потоков. Одним из наиболее распространенных
решений является использование идиомы Double-Check Locking (двойной проверки блокировки),
чтобы отдельные потоки не создавали новые экземпляры синглтона одновременно.
```
Следующая реализация позволяет только одному потоку входить в критическую область,
которую определяет блок lock, когда ещё не создан экземпляр Singleton.

![screen capture 3](Singleton/03.png)

Такой подход гарантирует создание только одного экземпляра и только тогда, когда
требуется экземпляр.
#### Кроме того, переменная объявлена как volatile, чтобы гарантировать, что присвоение ####
#### переменной экземпляра завершается до того, как к переменной экземпляра можно будет ####
#### получить доступ. ####
Наконец, этот подход использует экземпляр syncRoot для блокировки, а не для блокировки
самого типа, чтобы избежать взаимоблокировок.

***
Этот подход двойной проверки блокировки решает проблемы параллелизма потоков, избегая
монопольной блокировки при каждом вызове метода свойства экземпляра. Это также позволяет
отложить создание экземпляра до первого обращения к объекту.
_________________________________________________________________________________________
